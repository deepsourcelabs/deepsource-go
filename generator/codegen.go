package generator

import "github.com/dave/jennifer/jen"

// codeGenerator generates Go code for running the analysis. The code generator takes care of setting up boilerplate code (registering analyzers, etc.)
func codeGenerator(analyzerRuleMap map[string][]string) *jen.File {
	// create new file
	f := jen.NewFile("main")
	f.PackageComment("Code generated by DeepSource. DO NOT EDIT.")

	var statements []jen.Code

	// generate the analyzer import statement
	analyzerImport := jen.Id("p").Op(":=").Qual("github.com/deepsourcelabs/deepsource-go/analyzers/goast", "GoASTAnalyzer").Values(
		jen.Dict{
			jen.Id("Name"): jen.Lit("go-ast"),
		},
	)

	statements = append(statements, analyzerImport)

	// generate code for registering analyzers to a analyzer
	for analyzerName, analyzerRules := range analyzerRuleMap {
		if analyzerName != "" {
			for _, analyzer := range analyzerRules {
				// TODO: the CLI should handle the import path for package rules
				// currently, the code generator uses a static as the import path
				registerCode := jen.Id("p").Op(".").Id("RegisterRule").Call(jen.Qual("rules", analyzer))

				statements = append(statements, registerCode)
			}
		}
	}

	// generate code for calling BuildAST on a analyzer
	buildAST := jen.List(jen.Id("files"), jen.Err()).Op(":=").Id("p").Op(".").Id("BuildAST").Call(jen.Qual("os", "Getenv").Call(jen.Lit("CODE_PATH")))
	statements = append(statements, buildAST)

	// generate code for handling errors
	errCheck := jen.If(
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Qual("log", "Fatalln").Call(jen.Err()),
	)
	statements = append(statements, errCheck)

	// generate code for calling Run on a analyzer
	run := jen.Err().Op("=").Id("p").Op(".").Id("Run").Call(jen.Id("files"))
	statements = append(statements, run, errCheck)

	// enclose all statements inside main function
	f.Func().Id("main").Params().Block(
		statements...,
	)

	return f
}
