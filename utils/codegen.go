package utils

import "github.com/dave/jennifer/jen"

// codeGenerator generates Go code for running the analysis. The code generator takes care of setting up boilerplate code (registering plugins, etc.)
func codeGenerator(pluginAnalyzerMap map[string][]string) *jen.File {
	// create new file
	f := jen.NewFile("main")
	f.PackageComment("Code generated by DeepSource. DO NOT EDIT.")

	var statements []jen.Code

	// generate the plugin import statement
	pluginImport := jen.Id("p").Op(":=").Qual("github.com/deepsourcelabs/deepsource-go/plugins", "GoASTPlugin").Values(
		jen.Dict{
			jen.Id("Name"): jen.Lit("go-ast"),
		},
	)

	statements = append(statements, pluginImport)

	// generate code for registering analyzers to a plugin
	for pluginName, pluginAnalyzers := range pluginAnalyzerMap {
		if pluginName != "" {
			for _, analyzer := range pluginAnalyzers {
				registerCode := jen.Id("p").Op(".").Id("RegisterRule").Call(jen.Id(analyzer))

				statements = append(statements, registerCode)
			}
		}
	}

	// generate code for calling BuildAST on a plugin
	buildAST := jen.List(jen.Id("files"), jen.Err()).Op(":=").Id("p").Op(".").Id("BuildAST").Call(jen.Lit("test_dir"))
	statements = append(statements, buildAST)

	// generate code for handling errors
	errCheck := jen.If(
		jen.Err().Op("!=").Nil(),
	).Block(
		jen.Qual("log", "Fatalln").Call(jen.Err()),
	)
	statements = append(statements, errCheck)

	// generate code for calling Run on a plugin
	run := jen.Err().Op("=").Id("p").Op(".").Id("Run").Call(jen.Id("files"))
	statements = append(statements, run, errCheck)

	// enclose all statements inside main function
	f.Func().Id("main").Params().Block(
		statements...,
	)

	return f
}
